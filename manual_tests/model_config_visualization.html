<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Model Visualization</title>
    <style>
        /* Basic Reset */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body.dark-theme {
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        body.dark-theme .controls,
        body.dark-theme .info-panel,
        body.dark-theme .node-menu,
        body.dark-theme .help-tooltip,
        body.dark-theme .zoom-controls,
        body.dark-theme button,
        body.dark-theme input {
            background-color: #252526;
            color: #d4d4d4;
            border-color: #3c3c3c;
        }
        body.dark-theme button:hover,
        body.dark-theme .menu-item:hover {
            background-color: #3e3e3e;
        }
        body.dark-theme .zoom-button {
            background: #3775c9; /* Darker blue for dark theme */
        }
        body.dark-theme th {
            background-color: #333;
        }
        body.dark-theme td, body.dark-theme th {
            border-bottom-color: #444;
        }
        body.dark-theme .layer-path {
            background-color: #2a2a2a;
            border-color: #444;
        }
        body.dark-theme #searchInput {
            background-color: #3c3c3c;
            color: #d4d4d4;
        }
        body.dark-theme .visualization-container {
            border-color: #3c3c3c;
        }
        body.dark-theme .resize-handle {
            background-color: #252526;
            border-top-color: #3c3c3c;
        }

        body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 20px;
  display: flex;
  flex-direction: column;
  height: 100vh;
}
.visualization-container {
  flex: 1;
  overflow: auto;
  border: 1px solid #ccc;
  margin-bottom: 20px;
  padding: 10px;
  position: relative;
}
.info-panel {
  height: 200px;
  overflow: auto;
  border: 1px solid #ccc;
  padding: 10px;
  background-color: #f9f9f9;
}
.controls {
  margin-bottom: 10px;
  padding: 10px;
  background-color: #f0f0f0;
  border-radius: 4px;
}
.zoom-controls {
  position: absolute;
  top: 20px;
  right: 20px;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 5px;
}
.zoom-button {
  cursor: pointer;
  margin: 0 5px;
  background: #4285F4;
  color: white;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
}
.copy-notification {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 20px;
  background-color: #333;
  color: white;
  border-radius: 4px;
  opacity: 0;
  transition: opacity 0.5s;
}

.copy-notification.success {
  background-color: #4CAF50; /* Green for success */
}

.copy-notification.error {
  background-color: #F44336; /* Red for error */
}

.copy-notification.info {
  background-color: #2196F3; /* Blue for info */
}

table {
  border-collapse: collapse;
  width: 100%;
}
th, td {
  padding: 8px;
  text-align: left;
  border-bottom: 1px solid #ddd;
}
th {
  background-color: #f2f2f2;
}
.highlight-node {
  stroke: #FF5722 !important;
  stroke-width: 3px !important;
}
.fade {
  opacity: 0.3;
  transition: opacity 0.3s;
}
.node-menu {
  position: absolute;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 5px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  z-index: 100;
  display: none;
}
.menu-item {
  cursor: pointer;
  padding: 5px 10px;
}
.menu-item:hover {
  background-color: #f0f0f0;
}
.export-btn {
  margin-top: 10px;
  padding: 8px 16px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
.export-btn:hover {
  background-color: #45a049;
}
.layer-path {
  font-family: monospace;
  padding: 5px;
  background-color: #f5f5f5;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin: 5px 0;
  word-break: break-all;
}

/* New styles for collapsible nodes */
.hidden-node {
  display: none !important;
}

.collapsed-node polygon,
.collapsed-node rect {
  fill: #FFC107 !important; /* Yellow background for collapsed nodes */
}

.collapsed-node:after {
  content: "+";
  position: absolute;
  right: 5px;
  top: 50%;
  transform: translateY(-50%);
  font-weight: bold;
  font-size: 14px;
}

/* Draggable node styles */
[id^="node_"] {
  cursor: pointer;
  transition: filter 0.2s;
}

[id^="node_"]:hover {
  filter: brightness(1.05);
}

[id^="node_"].dragging {
  cursor: grabbing !important;
  filter: brightness(1.1) drop-shadow(0 2px 5px rgba(0,0,0,0.2));
}

/* Help tooltip */
.help-tooltip {
  position: fixed;
  right: 20px;
  bottom: 20px;
  background: white;
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 15px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  display: none;
  z-index: 1000;
  max-width: 300px;
}

.help-tooltip h3 {
  margin-top: 0;
  border-bottom: 1px solid #eee;
  padding-bottom: 8px;
}

.help-tooltip ul {
  margin: 0;
  padding-left: 20px;
}

.help-tooltip li {
  margin-bottom: 8px;
}

/* Improve button styles */
button {
  cursor: pointer;
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 5px 10px;
  margin-right: 5px;
  transition: background-color 0.2s;
}

button:hover {
  background-color: #e0e0e0;
}

/* Improved search input */
#searchInput {
  padding: 5px 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  width: 200px;
  margin-right: 5px;
}

/* Animation for transitions */
svg g {
  transition: opacity 0.3s, transform 0.1s;
}

.highlight-path-segment polygon,
.highlight-path-segment rect {
  stroke: #4CAF50 !important; /* Green for path */
  stroke-width: 2.5px !important;
  fill-opacity: 0.8 !important;
}

.highlight-path-segment text {
  font-weight: bold;
}

/* Styles for expansion indicator */
.expansion-indicator {
  font-family: monospace;
  font-size: 16px;
  fill: #333;
  cursor: pointer;
}

body.dark-theme .expansion-indicator {
  fill: #ccc;
}

/* Resizable container */
.resize-handle {
  width: 100%;
  height: 10px;
  background-color: #f0f0f0;
  cursor: ns-resize;
  border-top: 1px solid #ccc;
}

/* Ensure SVG takes full width of its container for pan/zoom to work correctly */
#svgPanZoomContainer svg {
    display: block; /* Removes extra space below inline SVGs */
    width: 100%;
    height: 100%;
    max-width: 100%; /* Ensure it doesn't overflow */
    max-height: 100%; /* Ensure it doesn't overflow */
}

.svg-pan-zoom-container {
    width: 100%;
    height: 100%;
    overflow: hidden; /* Crucial for svg-pan-zoom */
}

        /* Loading Spinner */
        .loading-spinner {
            border: 5px solid #f3f3f3; /* Light grey */
            border-top: 5px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001; /* Above node menu */
        }
        body.dark-theme .loading-spinner {
            border-color: #444;
            border-top-color: #3775c9;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
    
        .config-panel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .config-panel .config-body {
            background: white;
            padding: 20px;
            max-width: 700px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            overflow-y: auto;
            max-height: 90vh;
        }
        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .config-header h2 {
            margin: 0;
            color: #333;
        }
        #closeConfig {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #777;
        }
        .config-section {
            margin-bottom: 20px;
        }
        .config-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #444;
            font-size: 16px;
        }
        .selected-layers {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
        }
        .layer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin-bottom: 5px;
            background: #f5f5f5;
            border-radius: 3px;
        }
        .layer-item:last-child {
            margin-bottom: 0;
        }
        .layer-name {
            font-weight: bold;
            margin-right: 10px;
        }
        .layer-type {
            color: #777;
            font-size: 0.9em;
        }
        .remove-layer {
            background: none;
            border: none;
            color: #d33;
            cursor: pointer;
            font-size: 16px;
        }
        .param-group {
            margin-bottom: 15px;
        }
        .param-name {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .param-values {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .param-checkbox {
            display: flex;
            align-items: center;
            background: #f5f5f5;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .param-checkbox input {
            margin-right: 5px;
        }
        .config-options {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }
        .code-container {
            position: relative;
        }
        .generated-code {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: monospace;
            margin: 0;
        }
        .code-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #eee;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            cursor: pointer;
        }
        .code-button:hover {
            background: #ddd;
        }
        .config-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        .action-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .action-button:not(.secondary) {
            background: #4a86e8;
            color: white;
        }
        .action-button.secondary {
            background: #f5f5f5;
            color: #444;
        }        .no-selection {
            color: #777;
            font-style: italic;
        }
        .show-config-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #4a86e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .multi-select-tooltip {
            display: none;
            position: fixed;
            bottom: 60px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .node-selected {
            stroke: #4a86e8 !important;
            stroke-width: 3px !important;
        }
        .layer-type-group {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fafafa;
        }
        .layer-type-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        .layer-type-items {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .type-section {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            background-color: #fafafa;
        }
        .type-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        .type-warning {
            background-color: #fff8e6;
            border-left: 4px solid #ffc107;
            padding: 8px 12px;
            margin-bottom: 15px;
            color: #856404;
            font-size: 0.9em;
        }
        .param-options {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
        }
        .selection-help {
            font-size: 0.8em;
            color: #666;
            font-weight: normal;
            font-style: italic;
        }        .selection-tip {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #f0f7ff;
            border-left: 4px solid #4a86e8;
            font-size: 0.9em;
            color: #333;
            display: flex;
            align-items: flex-start;
        }
        .tip-icon {
            font-size: 1.2em;
            margin-right: 10px;
        }
        .tip-text {
            flex: 1;
        }
        kbd {
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.2);
            color: #333;
            display: inline-block;
            font-family: monospace;
            font-size: 0.9em;
            line-height: 1;
            padding: 2px 5px;
            margin: 0 2px;
        }        .multi-selection-active {
            background-color: #e6f7ff !important;
            border: 2px dashed #4a86e8 !important;
            position: relative;
            transition: all 0.3s ease;
        }
        .multi-selection-active::before {
            content: "Multi-select mode";
            position: absolute;
            top: -18px;
            right: 10px;
            font-size: 12px;
            background: #4a86e8;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .layers-included {
            font-size: 0.85em;
            color: #555;
            margin-bottom: 10px;
            padding: 5px 0;
            border-bottom: 1px dotted #ddd;
        }
        .multi-select-tooltip {
            display: none;
            position: fixed;
            bottom: 60px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        </style>
</head>
<body>
    <h1>Interactive Model Visualization</h1>
    <div class="controls" role="toolbar" aria-label="Visualization Controls">
        <button id="expandAll" title="Expand all nodes">Expand All</button>
        <button id="collapseAll" title="Collapse all top-level nodes">Collapse All</button>
        <input type="text" id="searchInput" placeholder="Search (e.g., name, type:Conv2d)" aria-label="Search modules">
        <button id="clearSearch" title="Clear search input">Clear</button>
        <button id="exportJSON" class="export-btn" title="Export model structure as JSON">Export JSON</button>
        <button id="themeToggle" title="Toggle light/dark theme">Toggle Theme</button>
        <button id="helpButton" title="Show help and keyboard shortcuts (?)">Help (?)</button>
    </div>

    <div class="visualization-container" id="visualizationContainer" role="application" aria-roledescription="Interactive model graph">
        <div id="loadingIndicator" class="loading-spinner" style="display: none;"></div>
        <div class="svg-pan-zoom-container" id="svgPanZoomContainer">
             <?xml version="1.0" encoding="UTF-8" standalone="no"?>

<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"

 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<!-- Generated by graphviz version 12.2.1 (20241206.2353)

 -->

<!-- Title: model_visualization Pages: 1 -->

<svg width="800pt" height="211pt"

 viewBox="0.00 0.00 800.15 211.40" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 207.4)">

<title>model_visualization</title>

<!-- node_root_model -->

<g id="node_root_model" class="node" data-name="root">

<title>node_root_model</title>

<g id="a_node_root_model"><a xlink:title="Root: SimpleModel&#10;Parameters: 567,434">

<path fill="#d1e7f7" stroke="#4285f4" d="M239.85,-174.1C239.85,-174.1 337.05,-174.1 337.05,-174.1 341.85,-174.1 346.65,-178.9 346.65,-183.7 346.65,-183.7 346.65,-193.3 346.65,-193.3 346.65,-198.1 341.85,-202.9 337.05,-202.9 337.05,-202.9 239.85,-202.9 239.85,-202.9 235.05,-202.9 230.25,-198.1 230.25,-193.3 230.25,-193.3 230.25,-183.7 230.25,-183.7 230.25,-178.9 235.05,-174.1 239.85,-174.1" data-name="root"/>

<text text-anchor="middle" x="288.45" y="-184.8" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="root">model (SimpleModel)</text>

</a>

</g>

</g>

<!-- node_classifier -->

<g id="node_classifier" class="node" data-name="classifier">

<title>node_classifier</title>

<g id="a_node_classifier"><a xlink:title="Name: classifier&#10;Type: Sequential&#10;Parameters: 34,186&#10;Trainable: Yes">

<path fill="#e5f5fd" stroke="#4285f4" d="M234.42,-115.6C234.42,-115.6 136.47,-115.6 136.47,-115.6 131.67,-115.6 126.87,-110.8 126.87,-106 126.87,-106 126.87,-96.4 126.87,-96.4 126.87,-91.6 131.67,-86.8 136.47,-86.8 136.47,-86.8 234.42,-86.8 234.42,-86.8 239.22,-86.8 244.02,-91.6 244.02,-96.4 244.02,-96.4 244.02,-106 244.02,-106 244.02,-110.8 239.22,-115.6 234.42,-115.6" data-name="classifier"/>

<text text-anchor="middle" x="185.45" y="-97.5" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="classifier">classifier (Sequential)</text>

</a>

</g>

</g>

<!-- node_root_model&#45;&gt;node_classifier -->

<g id="edge_node_root_model_node_classifier" class="edge">

<title>node_root_model&#45;&gt;node_classifier</title>

<path fill="none" stroke="#757575" d="M237.14,-173.69C237.14,-173.69 237.14,-124.6 237.14,-124.6"/>

<polygon fill="#757575" stroke="#757575" points="239.59,-124.6 237.14,-117.6 234.69,-124.6 239.59,-124.6"/>

</g>

<!-- node_features -->

<g id="node_features" class="node" data-name="features">

<title>node_features</title>

<g id="a_node_features"><a xlink:title="Name: features&#10;Type: Sequential&#10;Parameters: 533,248&#10;Trainable: Yes">

<path fill="#e5f5fd" stroke="#4285f4" d="M545.3,-115.6C545.3,-115.6 449.6,-115.6 449.6,-115.6 444.8,-115.6 440,-110.8 440,-106 440,-106 440,-96.4 440,-96.4 440,-91.6 444.8,-86.8 449.6,-86.8 449.6,-86.8 545.3,-86.8 545.3,-86.8 550.1,-86.8 554.9,-91.6 554.9,-96.4 554.9,-96.4 554.9,-106 554.9,-106 554.9,-110.8 550.1,-115.6 545.3,-115.6" data-name="features"/>

<text text-anchor="middle" x="497.45" y="-97.5" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="features">features (Sequential)</text>

</a>

</g>

</g>

<!-- node_root_model&#45;&gt;node_features -->

<g id="edge_node_root_model_node_features" class="edge">

<title>node_root_model&#45;&gt;node_features</title>

<path fill="none" stroke="#757575" d="M328.32,-173.75C328.32,-150.02 328.32,-106 328.32,-106 328.32,-106 431.21,-106 431.21,-106"/>

<polygon fill="#757575" stroke="#757575" points="431.21,-108.45 438.21,-106 431.21,-103.55 431.21,-108.45"/>

</g>

<!-- node_classifier_0 -->

<g id="node_classifier_0" class="node" data-name="classifier.0">

<title>node_classifier_0</title>

<g id="a_node_classifier_0"><a xlink:title="Name: classifier.0&#10;Type: Linear&#10;Parameters: 32,896&#10;Trainable: Yes">

<path fill="#c2e0f4" stroke="#4285f4" d="M51.3,-28.8C51.3,-28.8 9.6,-28.8 9.6,-28.8 4.8,-28.8 0,-24 0,-19.2 0,-19.2 0,-9.6 0,-9.6 0,-4.8 4.8,0 9.6,0 9.6,0 51.3,0 51.3,0 56.1,0 60.9,-4.8 60.9,-9.6 60.9,-9.6 60.9,-19.2 60.9,-19.2 60.9,-24 56.1,-28.8 51.3,-28.8" data-name="classifier.0"/>

<text text-anchor="middle" x="30.45" y="-10.7" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="classifier.0">0 (Linear)</text>

</a>

</g>

</g>

<!-- node_classifier&#45;&gt;node_classifier_0 -->

<g id="edge_node_classifier_node_classifier_0" class="edge">

<title>node_classifier&#45;&gt;node_classifier_0</title>

<path fill="none" stroke="#757575" d="M126.41,-101C82.61,-101 30.45,-101 30.45,-101 30.45,-101 30.45,-37.6 30.45,-37.6"/>

<polygon fill="#757575" stroke="#757575" points="32.9,-37.6 30.45,-30.6 28,-37.6 32.9,-37.6"/>

</g>

<!-- node_classifier_1 -->

<g id="node_classifier_1" class="node" data-name="classifier.1">

<title>node_classifier_1</title>

<g id="a_node_classifier_1"><a xlink:title="Name: classifier.1&#10;Type: ReLU&#10;Parameters: 0&#10;Trainable: No">

<path fill="#c2e0f4" stroke="#4285f4" d="M153.55,-28.8C153.55,-28.8 113.35,-28.8 113.35,-28.8 108.55,-28.8 103.75,-24 103.75,-19.2 103.75,-19.2 103.75,-9.6 103.75,-9.6 103.75,-4.8 108.55,0 113.35,0 113.35,0 153.55,0 153.55,0 158.35,0 163.15,-4.8 163.15,-9.6 163.15,-9.6 163.15,-19.2 163.15,-19.2 163.15,-24 158.35,-28.8 153.55,-28.8" data-name="classifier.1"/>

<text text-anchor="middle" x="133.45" y="-10.7" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="classifier.1">1 (ReLU)</text>

</a>

</g>

</g>

<!-- node_classifier&#45;&gt;node_classifier_1 -->

<g id="edge_node_classifier_node_classifier_1" class="edge">

<title>node_classifier&#45;&gt;node_classifier_1</title>

<path fill="none" stroke="#757575" d="M145.01,-86.48C145.01,-86.48 145.01,-37.71 145.01,-37.71"/>

<polygon fill="#757575" stroke="#757575" points="147.46,-37.71 145.01,-30.71 142.56,-37.71 147.46,-37.71"/>

</g>

<!-- node_classifier_2 -->

<g id="node_classifier_2" class="node" data-name="classifier.2">

<title>node_classifier_2</title>

<g id="a_node_classifier_2"><a xlink:title="Name: classifier.2&#10;Type: Linear&#10;Parameters: 1,290&#10;Trainable: Yes">

<path fill="#c2e0f4" stroke="#4285f4" d="M257.3,-28.8C257.3,-28.8 215.6,-28.8 215.6,-28.8 210.8,-28.8 206,-24 206,-19.2 206,-19.2 206,-9.6 206,-9.6 206,-4.8 210.8,0 215.6,0 215.6,0 257.3,0 257.3,0 262.1,0 266.9,-4.8 266.9,-9.6 266.9,-9.6 266.9,-19.2 266.9,-19.2 266.9,-24 262.1,-28.8 257.3,-28.8" data-name="classifier.2"/>

<text text-anchor="middle" x="236.45" y="-10.7" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="classifier.2">2 (Linear)</text>

</a>

</g>

</g>

<!-- node_classifier&#45;&gt;node_classifier_2 -->

<g id="edge_node_classifier_node_classifier_2" class="edge">

<title>node_classifier&#45;&gt;node_classifier_2</title>

<path fill="none" stroke="#757575" d="M225.01,-86.48C225.01,-86.48 225.01,-37.71 225.01,-37.71"/>

<polygon fill="#757575" stroke="#757575" points="227.46,-37.71 225.01,-30.71 222.56,-37.71 227.46,-37.71"/>

</g>

<!-- node_features_0 -->

<g id="node_features_0" class="node" data-name="features.0">

<title>node_features_0</title>

<g id="a_node_features_0"><a xlink:title="Name: features.0&#10;Type: Linear&#10;Parameters: 401,920&#10;Trainable: Yes">

<path fill="#c2e0f4" stroke="#4285f4" d="M361.3,-28.8C361.3,-28.8 319.6,-28.8 319.6,-28.8 314.8,-28.8 310,-24 310,-19.2 310,-19.2 310,-9.6 310,-9.6 310,-4.8 314.8,0 319.6,0 319.6,0 361.3,0 361.3,0 366.1,0 370.9,-4.8 370.9,-9.6 370.9,-9.6 370.9,-19.2 370.9,-19.2 370.9,-24 366.1,-28.8 361.3,-28.8" data-name="features.0"/>

<text text-anchor="middle" x="340.45" y="-10.7" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="features.0">0 (Linear)</text>

</a>

</g>

</g>

<!-- node_features&#45;&gt;node_features_0 -->

<g id="edge_node_features_node_features_0" class="edge">

<title>node_features&#45;&gt;node_features_0</title>

<path fill="none" stroke="#757575" d="M439.84,-96C401.74,-96 358.77,-96 358.77,-96 358.77,-96 358.77,-37.5 358.77,-37.5"/>

<polygon fill="#757575" stroke="#757575" points="361.23,-37.5 358.78,-30.5 356.33,-37.5 361.23,-37.5"/>

</g>

<!-- node_features_1 -->

<g id="node_features_1" class="node" data-name="features.1">

<title>node_features_1</title>

<g id="a_node_features_1"><a xlink:title="Name: features.1&#10;Type: ReLU&#10;Parameters: 0&#10;Trainable: No">

<path fill="#c2e0f4" stroke="#4285f4" d="M463.55,-28.8C463.55,-28.8 423.35,-28.8 423.35,-28.8 418.55,-28.8 413.75,-24 413.75,-19.2 413.75,-19.2 413.75,-9.6 413.75,-9.6 413.75,-4.8 418.55,0 423.35,0 423.35,0 463.55,0 463.55,0 468.35,0 473.15,-4.8 473.15,-9.6 473.15,-9.6 473.15,-19.2 473.15,-19.2 473.15,-24 468.35,-28.8 463.55,-28.8" data-name="features.1"/>

<text text-anchor="middle" x="443.45" y="-10.7" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="features.1">1 (ReLU)</text>

</a>

</g>

</g>

<!-- node_features&#45;&gt;node_features_1 -->

<g id="edge_node_features_node_features_1" class="edge">

<title>node_features&#45;&gt;node_features_1</title>

<path fill="none" stroke="#757575" d="M456.57,-86.48C456.57,-86.48 456.57,-37.71 456.57,-37.71"/>

<polygon fill="#757575" stroke="#757575" points="459.03,-37.71 456.58,-30.71 454.13,-37.71 459.03,-37.71"/>

</g>

<!-- node_features_2 -->

<g id="node_features_2" class="node" data-name="features.2">

<title>node_features_2</title>

<g id="a_node_features_2"><a xlink:title="Name: features.2&#10;Type: Dropout&#10;Parameters: 0&#10;Trainable: No">

<path fill="#c2e0f4" stroke="#4285f4" d="M576.8,-28.8C576.8,-28.8 526.1,-28.8 526.1,-28.8 521.3,-28.8 516.5,-24 516.5,-19.2 516.5,-19.2 516.5,-9.6 516.5,-9.6 516.5,-4.8 521.3,0 526.1,0 526.1,0 576.8,0 576.8,0 581.6,0 586.4,-4.8 586.4,-9.6 586.4,-9.6 586.4,-19.2 586.4,-19.2 586.4,-24 581.6,-28.8 576.8,-28.8" data-name="features.2"/>

<text text-anchor="middle" x="551.45" y="-10.7" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="features.2">2 (Dropout)</text>

</a>

</g>

</g>

<!-- node_features&#45;&gt;node_features_2 -->

<g id="edge_node_features_node_features_2" class="edge">

<title>node_features&#45;&gt;node_features_2</title>

<path fill="none" stroke="#757575" d="M535.7,-86.48C535.7,-86.48 535.7,-37.71 535.7,-37.71"/>

<polygon fill="#757575" stroke="#757575" points="538.15,-37.71 535.7,-30.71 533.25,-37.71 538.15,-37.71"/>

</g>

<!-- node_features_3 -->

<g id="node_features_3" class="node" data-name="features.3">

<title>node_features_3</title>

<g id="a_node_features_3"><a xlink:title="Name: features.3&#10;Type: Linear&#10;Parameters: 131,328&#10;Trainable: Yes">

<path fill="#c2e0f4" stroke="#4285f4" d="M680.3,-28.8C680.3,-28.8 638.6,-28.8 638.6,-28.8 633.8,-28.8 629,-24 629,-19.2 629,-19.2 629,-9.6 629,-9.6 629,-4.8 633.8,0 638.6,0 638.6,0 680.3,0 680.3,0 685.1,0 689.9,-4.8 689.9,-9.6 689.9,-9.6 689.9,-19.2 689.9,-19.2 689.9,-24 685.1,-28.8 680.3,-28.8" data-name="features.3"/>

<text text-anchor="middle" x="659.45" y="-10.7" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="features.3">3 (Linear)</text>

</a>

</g>

</g>

<!-- node_features&#45;&gt;node_features_3 -->

<g id="edge_node_features_node_features_3" class="edge">

<title>node_features&#45;&gt;node_features_3</title>

<path fill="none" stroke="#757575" d="M555.02,-96C601.58,-96 659.45,-96 659.45,-96 659.45,-96 659.45,-37.5 659.45,-37.5"/>

<polygon fill="#757575" stroke="#757575" points="661.9,-37.5 659.45,-30.5 657,-37.5 661.9,-37.5"/>

</g>

<!-- node_features_4 -->

<g id="node_features_4" class="node" data-name="features.4">

<title>node_features_4</title>

<g id="a_node_features_4"><a xlink:title="Name: features.4&#10;Type: ReLU&#10;Parameters: 0&#10;Trainable: No">

<path fill="#c2e0f4" stroke="#4285f4" d="M782.55,-28.8C782.55,-28.8 742.35,-28.8 742.35,-28.8 737.55,-28.8 732.75,-24 732.75,-19.2 732.75,-19.2 732.75,-9.6 732.75,-9.6 732.75,-4.8 737.55,0 742.35,0 742.35,0 782.55,0 782.55,0 787.35,0 792.15,-4.8 792.15,-9.6 792.15,-9.6 792.15,-19.2 792.15,-19.2 792.15,-24 787.35,-28.8 782.55,-28.8" data-name="features.4"/>

<text text-anchor="middle" x="762.45" y="-10.7" font-family="Arial, Helvetica, sans-serif" font-size="11.00" data-name="features.4">4 (ReLU)</text>

</a>

</g>

</g>

<!-- node_features&#45;&gt;node_features_4 -->

<g id="edge_node_features_node_features_4" class="edge">

<title>node_features&#45;&gt;node_features_4</title>

<path fill="none" stroke="#757575" d="M555.28,-106C633.25,-106 762.45,-106 762.45,-106 762.45,-106 762.45,-37.63 762.45,-37.63"/>

<polygon fill="#757575" stroke="#757575" points="764.9,-37.63 762.45,-30.63 760,-37.63 764.9,-37.63"/>

</g>

</g>

</svg>


        </div>
        <div class="zoom-controls" role="group" aria-label="Zoom Controls">
            <button class="zoom-button" id="zoomIn" title="Zoom In (+)">+</button>
            <button class="zoom-button" id="zoomOut" title="Zoom Out (-)">-</button>
            <button class="zoom-button" id="resetZoom" title="Reset Zoom (100%)">Reset</button>
        </div>
    </div>
    <div class="resize-handle" id="resizeHandle" title="Resize visualization area" aria-label="Resize Handle"></div>

    <div class="info-panel" id="infoPanel" role="region" aria-live="polite" aria-labelledby="infoPanelHeader">
        <h3 id="infoPanelHeader">Module Information</h3>
        <p>Click on a module in the visualization to view its details.</p>
    </div>

    <div class="copy-notification" id="copyNotification" role="alert" aria-live="assertive">Module name copied to clipboard!</div>

    <div class="node-menu" id="nodeMenu" role="menu" aria-hidden="true">
        <div class="menu-item" id="copyName" role="menuitem">Copy Module Name</div>
        <div class="menu-item" id="showDetails" role="menuitem">Show Details</div>
        <div class="menu-item" id="highlightPath" role="menuitem">Highlight Path</div>
        <div class="menu-item" id="toggleCollapse" role="menuitem">Toggle Collapse</div>
    </div>

    <div class="help-tooltip" id="helpTooltip" role="dialog" aria-labelledby="helpTooltipHeader" aria-hidden="true">
      <h3 id="helpTooltipHeader">Keyboard Shortcuts & Tips</h3>
      <button id="closeHelpTooltip" aria-label="Close help" style="float: right; font-size: 1.2em; line-height: 1; padding: 0.2em 0.4em;">&times;</button>
      <ul>
        <li><b>Double-click node</b>: Collapse/expand node</li>
        <li><b>Right-click node</b>: Show context menu</li>
        <li><b>Alt + Drag / Middle-click Drag</b>: Move individual node</li>
        <li><b>Ctrl + Scroll / Pinch</b>: Zoom SVG</li>
        <li><b>Shift + Drag SVG</b>: Pan SVG</li>
        <li><b>Ctrl+F</b>: Focus search bar</li>
        <li><b>Esc</b>: Clear search / Close help</li>
        <li><b>? or Ctrl+H</b>: Show/hide this help</li>
      </ul>
      <p>Search examples: <code>MyLayer</code>, <code>type:Linear</code>, <code>trainable:yes</code>, <code>params:>1000</code></p>
    </div>

    <script>
        // Module information from Python
        const moduleInfo = {"root": {"type": "SimpleModel", "parameters": 567434, "trainable": true, "class": "<class '__main__.SimpleModel'>", "docstring": "A simple model with various layer types for demonstrating the ConfigVisualizer"}, "features": {"type": "Sequential", "parameters": 533248, "trainable": true, "class": "<class 'torch.nn.modules.container.Sequential'>", "docstring": "A sequential container."}, "features.0": {"type": "Linear", "parameters": 401920, "trainable": true, "class": "<class 'torch.nn.modules.linear.Linear'>", "docstring": "Applies an affine linear transformation to the incoming data: :math:`y = xA^T + b`.", "in_features": 784, "out_features": 512, "bias": true}, "features.1": {"type": "ReLU", "parameters": 0, "trainable": false, "class": "<class 'torch.nn.modules.activation.ReLU'>", "docstring": "Applies the rectified linear unit function element-wise."}, "features.2": {"type": "Dropout", "parameters": 0, "trainable": false, "class": "<class 'torch.nn.modules.dropout.Dropout'>", "docstring": "During training, randomly zeroes some of the elements of the input tensor with probability :attr:`p`.", "p": 0.2, "inplace": false}, "features.3": {"type": "Linear", "parameters": 131328, "trainable": true, "class": "<class 'torch.nn.modules.linear.Linear'>", "docstring": "Applies an affine linear transformation to the incoming data: :math:`y = xA^T + b`.", "in_features": 512, "out_features": 256, "bias": true}, "features.4": {"type": "ReLU", "parameters": 0, "trainable": false, "class": "<class 'torch.nn.modules.activation.ReLU'>", "docstring": "Applies the rectified linear unit function element-wise."}, "classifier": {"type": "Sequential", "parameters": 34186, "trainable": true, "class": "<class 'torch.nn.modules.container.Sequential'>", "docstring": "A sequential container."}, "classifier.0": {"type": "Linear", "parameters": 32896, "trainable": true, "class": "<class 'torch.nn.modules.linear.Linear'>", "docstring": "Applies an affine linear transformation to the incoming data: :math:`y = xA^T + b`.", "in_features": 256, "out_features": 128, "bias": true}, "classifier.1": {"type": "ReLU", "parameters": 0, "trainable": false, "class": "<class 'torch.nn.modules.activation.ReLU'>", "docstring": "Applies the rectified linear unit function element-wise."}, "classifier.2": {"type": "Linear", "parameters": 1290, "trainable": true, "class": "<class 'torch.nn.modules.linear.Linear'>", "docstring": "Applies an affine linear transformation to the incoming data: :math:`y = xA^T + b`.", "in_features": 128, "out_features": 10, "bias": true}};
        
        // Setup interactive behavior
document.addEventListener('DOMContentLoaded', function() {
  const svgElement = document.querySelector('#svgPanZoomContainer svg'); // Target the SVG within the container
  const infoPanel = document.getElementById('infoPanel');
  const copyNotification = document.getElementById('copyNotification');
  const searchInput = document.getElementById('searchInput');
  const clearSearch = document.getElementById('clearSearch');
  const nodeMenu = document.getElementById('nodeMenu');
  const exportJSONBtn = document.getElementById('exportJSON');
  const expandAllBtn = document.getElementById('expandAll');
  const collapseAllBtn = document.getElementById('collapseAll');
  const themeToggleBtn = document.getElementById('themeToggle');
  const helpButton = document.getElementById('helpButton');
  const helpTooltip = document.getElementById('helpTooltip');
  const closeHelpTooltip = document.getElementById('closeHelpTooltip');
  const loadingIndicator = document.getElementById('loadingIndicator');
  const visualizationContainer = document.getElementById('visualizationContainer');
  const resizeHandle = document.getElementById('resizeHandle');

  // Track collapsed state of nodes by their data-name attribute
  const collapsedNodes = new Set();
  let svgPanZoomInstance; // To store the svg-pan-zoom instance

  // Function to show notification messages
  function showNotification(message, type = 'info') {
    if (!copyNotification) return;
    
    // Clear any existing timeout
    if (window.notificationTimeout) {
      clearTimeout(window.notificationTimeout);
    }
    
    // Set message and show
    copyNotification.textContent = message;
    copyNotification.className = 'copy-notification'; // Reset classes
    copyNotification.classList.add(type); // Add type class (success, error, info)
    copyNotification.style.opacity = '1';
    
    // Hide after delay
    window.notificationTimeout = setTimeout(() => {
      copyNotification.style.opacity = '0';
    }, 2000);
  }

  // Show loading indicator
  function showLoading(show = true) {
    if (loadingIndicator) {
      loadingIndicator.style.display = show ? 'block' : 'none';
    }
  }

  // Initialize SVG Pan Zoom (if the library is available)
  function initSvgPanZoom() {
    if (window.svgPanZoom && svgElement) {
      svgPanZoomInstance = svgPanZoom(svgElement, {
        zoomEnabled: true,
        controlIconsEnabled: false, // We use custom controls
        panEnabled: true,
        minZoom: 0.1,
        maxZoom: 10,
        zoomScaleSensitivity: 0.2,
        fit: true,
        center: true,
        onZoom: function() {
            // Future use: if needed to update something on zoom
        },
        onPan: function() {
            // Future use: if needed to update something on pan
        }
      });
      // Custom zoom buttons
      document.getElementById('zoomIn').addEventListener('click', () => svgPanZoomInstance.zoomIn());
      document.getElementById('zoomOut').addEventListener('click', () => svgPanZoomInstance.zoomOut());
      document.getElementById('resetZoom').addEventListener('click', () => svgPanZoomInstance.resetZoom());
    } else {
      console.warn('svg-pan-zoom library not found or SVG element missing. Pan and zoom will be basic.');
      // Fallback basic zoom (if svg-pan-zoom is not used)
      let zoomLevel = 1;
      const zoomInBasic = document.getElementById('zoomIn');
      const zoomOutBasic = document.getElementById('zoomOut');
      const resetZoomBasic = document.getElementById('resetZoom');

      function updateBasicZoom() {
          if (svgElement) {
            svgElement.style.transform = `scale(${zoomLevel})`;
            svgElement.style.transformOrigin = 'center center'; // Or 'top left'
          }
      }
      if (zoomInBasic) zoomInBasic.addEventListener('click', () => { zoomLevel = Math.min(10, zoomLevel + 0.1); updateBasicZoom(); });
      if (zoomOutBasic) zoomOutBasic.addEventListener('click', () => { zoomLevel = Math.max(0.1, zoomLevel - 0.1); updateBasicZoom(); });
      if (resetZoomBasic) resetZoomBasic.addEventListener('click', () => { zoomLevel = 1; updateBasicZoom(); });
    }
  }
  
  // Call init after SVG content is loaded (or if it's inline, DOMContentLoaded is enough)
  // If SVG is loaded dynamically, this might need to be called after SVG is injected.
  if (svgElement) {
    initSvgPanZoom();
  } else {
    console.error("SVG element for pan/zoom not found.");
  }


  // Theme Toggling
  function applyTheme(theme) {
    document.body.classList.toggle('dark-theme', theme === 'dark');
    localStorage.setItem('visualizationTheme', theme);
  }

  themeToggleBtn.addEventListener('click', () => {
    const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
    applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
  });

  // Load saved theme
  const savedTheme = localStorage.getItem('visualizationTheme');
  if (savedTheme) {
    applyTheme(savedTheme);
  } else {
    // Default to light or respect OS preference if desired
    applyTheme('light'); 
  }

  // Help Tooltip
  function toggleHelp(show) {
    if (helpTooltip) {
        helpTooltip.style.display = show ? 'block' : 'none';
        helpTooltip.setAttribute('aria-hidden', !show);
        if (show) helpTooltip.focus(); // For accessibility
    }
  }
  if (helpButton) helpButton.addEventListener('click', (e) => { e.stopPropagation(); toggleHelp(helpTooltip.style.display !== 'block'); });
  if (closeHelpTooltip) closeHelpTooltip.addEventListener('click', () => toggleHelp(false));


  // Global click listener to hide menus/tooltips
  document.addEventListener('click', function(e) {
    if (nodeMenu) nodeMenu.style.display = 'none';
    // If help is open and click is outside, close it
    if (helpTooltip && helpTooltip.style.display === 'block' && !helpTooltip.contains(e.target) && e.target !== helpButton) {
        // toggleHelp(false); // This line was causing issues with the help button itself.
    }
  });
  
  // Export JSON
  if (exportJSONBtn) exportJSONBtn.addEventListener('click', function() {
      showLoading(true);
      try {
        const json = JSON.stringify(window.moduleInfo || {}, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'model_info.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); // Clean up
        showNotification('Model data exported as JSON.', 'success');
      } catch (err) {
        console.error('Failed to export JSON:', err);
        showNotification('Error exporting JSON.', 'error');
      } finally {
        showLoading(false);
      }
  });
  
  // Function to get all descendant nodes (recursively)
  function getAllDescendantNodes(parentNodePath) {
      if (!svgElement || !parentNodePath) return [];
      return Array.from(svgElement.querySelectorAll('[data-name]')).filter(n => {
          const path = n.getAttribute('data-name');
          return path && path !== parentNodePath && path.startsWith(parentNodePath + '.');
      });
  }

  // Function to get direct child nodes
  function getDirectChildNodes(parentNodePath) {
      if (!svgElement || !parentNodePath) return [];
      return Array.from(svgElement.querySelectorAll('[data-name]')).filter(n => {
          const path = n.getAttribute('data-name');
          if (!path || path === parentNodePath || !path.startsWith(parentNodePath + '.')) return false;
          // A direct child's path should be parentNodePath.childName (no further dots)
          const remainder = path.substring(parentNodePath.length + 1);
          return remainder.indexOf('.') === -1;
      });
  }
  
  // Function to toggle node collapse state
  function toggleNodeCollapse(nodeToToggle, collapse, forceRecursive = false) {
      const modulePath = nodeToToggle.getAttribute('data-name');
      if (!modulePath) return;

      const directChildren = getDirectChildNodes(modulePath);

      if (collapse) {
          nodeToToggle.classList.add('collapsed-node');
          collapsedNodes.add(modulePath);
          directChildren.forEach(child => {
              child.classList.add('hidden-node');
              // If recursively collapsing, also hide children of children
              if (forceRecursive || collapsedNodes.has(child.getAttribute('data-name'))) {
                 getAllDescendantNodes(child.getAttribute('data-name')).forEach(n => n.classList.add('hidden-node'));
              }
          });
      } else {
          nodeToToggle.classList.remove('collapsed-node');
          collapsedNodes.delete(modulePath);
          directChildren.forEach(child => {
              child.classList.remove('hidden-node');
              // If this child itself was collapsed, don't expand its children unless explicitly told to
              if (!collapsedNodes.has(child.getAttribute('data-name'))) {
                  // This logic ensures that expanding a parent doesn't auto-expand a child that was individually collapsed.
                  // To show children of this child, they must not be hidden due to their own parent being collapsed.
                  const grandChildren = getDirectChildNodes(child.getAttribute('data-name'));
                  grandChildren.forEach(gc => {
                      if (!collapsedNodes.has(child.getAttribute('data-name'))) { // only show if immediate parent is now expanded
                           gc.classList.remove('hidden-node');
                      }
                  });
              }
          });
      }
      updateNodeExpansionIndicator(nodeToToggle);
  }

  function updateNodeExpansionIndicator(node) {
    const indicator = node.querySelector('.expansion-indicator');
    if (indicator) {
        indicator.textContent = collapsedNodes.has(node.getAttribute('data-name')) ? '+' : '-';
    }
  }
  
  // Add handlers to all potential nodes
  function setupNodeInteractions() {
    if (!svgElement) return;
    showLoading(true); // Show loading before processing nodes

    const allGraphNodes = svgElement.querySelectorAll('g[id^="node_"]');
    allGraphNodes.forEach(node => {
        const modulePath = node.getAttribute('data-name');
        if (!modulePath) {
            // console.warn('Node found without data-name:', node.id);
            return; // Skip nodes without a data-name, they are not part of the module tree
        }

        // Add expansion indicator if it has children
        const directChildren = getDirectChildNodes(modulePath);
        if (directChildren.length > 0) {
            let indicator = node.querySelector('.expansion-indicator');
            if (!indicator) {
                const textElement = node.querySelector('text'); // Assuming text exists for label
                if (textElement) {
                    indicator = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    indicator.setAttribute('class', 'expansion-indicator');
                    // Position relative to the existing text or a corner of the node
                    // This might need adjustment based on your node's SVG structure
                    const bbox = textElement.getBBox ? textElement.getBBox() : { x: 0, y: 0, width: 0, height: 0 };
                    indicator.setAttribute('x', bbox.x - 10); // Example positioning
                    indicator.setAttribute('y', bbox.y + bbox.height / 2 + 5); // Adjust as needed
                    indicator.style.cursor = 'pointer';
                    indicator.style.fontSize = '16px'; // Make it more visible
                    indicator.style.fontWeight = 'bold';
                    node.appendChild(indicator);
                }
            }
            if (indicator) {
                 indicator.textContent = collapsedNodes.has(modulePath) ? '+' : '-';
            }
        }


        node.style.cursor = 'pointer';
        
        // Double-click to collapse/expand
        node.addEventListener('dblclick', function(e) {
            e.stopPropagation();
            const currentModulePath = this.getAttribute('data-name');
            if (!currentModulePath) return;
            const isCollapsed = collapsedNodes.has(currentModulePath);
            toggleNodeCollapse(this, !isCollapsed);
        });
        
        // Single-click to show info and highlight
        node.addEventListener('click', function(e) {
            e.stopPropagation();
            const currentModulePath = this.getAttribute('data-name');
            if (!currentModulePath) return;
            
            displayModuleInfo(currentModulePath);
            
            allGraphNodes.forEach(n => n.classList.remove('highlight-node'));
            this.classList.add('highlight-node');
        });
        
        // Context menu
        node.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const currentModulePath = this.getAttribute('data-name');
            if (!currentModulePath) return;

            nodeMenu.style.display = 'block';
            nodeMenu.style.left = `${e.pageX}px`;
            nodeMenu.style.top = `${e.pageY}px`;
            nodeMenu.setAttribute('aria-hidden', 'false');
            
            // Update context menu items based on the node
            document.getElementById('copyName').onclick = (ev) => { ev.stopPropagation(); copyModuleName(currentModulePath); nodeMenu.style.display = 'none'; };
            document.getElementById('showDetails').onclick = (ev) => { ev.stopPropagation(); displayModuleInfo(currentModulePath); nodeMenu.style.display = 'none'; };
            document.getElementById('highlightPath').onclick = (ev) => { ev.stopPropagation(); highlightModulePath(currentModulePath); nodeMenu.style.display = 'none'; };
            
            const toggleCollapseItem = document.getElementById('toggleCollapse');
            const isNodeCollapsed = collapsedNodes.has(currentModulePath);
            toggleCollapseItem.textContent = isNodeCollapsed ? 'Expand Node' : 'Collapse Node';
            toggleCollapseItem.onclick = (ev) => {
                ev.stopPropagation();
                toggleNodeCollapse(this, !isNodeCollapsed);
                nodeMenu.style.display = 'none';
            };
        });

        // Make nodes draggable (Alt + Drag or Middle Mouse Drag)
        makeNodeDraggable(node);

        // Apply initially collapsed state if needed (e.g. after search or full collapse)
        if (collapsedNodes.has(modulePath) && !node.classList.contains('collapsed-node')) {
            toggleNodeCollapse(node, true, true); // force recursive hide
        } else if (!collapsedNodes.has(modulePath) && node.classList.contains('collapsed-node')) {
            // This case should ideally not happen if state is consistent
            node.classList.remove('collapsed-node');
        }
        updateNodeExpansionIndicator(node);
    });
    showLoading(false); // Hide loading after processing
  }
  
  // Call setupNodeInteractions once SVG is ready
  if (svgElement) {
      // If SVG is complex, defer to allow rendering first
      setTimeout(setupNodeInteractions, 100);
  }


  function copyModuleName(moduleName) {
    navigator.clipboard.writeText(moduleName).then(() => {
        showNotification(`Module name "${moduleName}" copied!`, 'success');
    }).catch(err => {
        console.error('Failed to copy module name: ', err);
        showNotification('Error copying name.', 'error');
    });
  }

  function highlightModulePath(moduleName) {
    if (!svgElement) return;
    const allGraphNodes = svgElement.querySelectorAll('g[id^="node_"]');
    allGraphNodes.forEach(n => n.classList.add('fade'));
    
    const parts = moduleName.split('.');
    let currentPath = '';
    for (let i = 0; i < parts.length; i++) {
        currentPath = i === 0 ? parts[i] : `${currentPath}.${parts[i]}`;
        const nodeToHighlight = svgElement.querySelector(`g[data-name="${currentPath}"]`);
        if (nodeToHighlight) {
            nodeToHighlight.classList.remove('fade');
            nodeToHighlight.classList.add('highlight-path-segment'); // For distinct path highlight
        }
    }
    
    setTimeout(() => { 
        allGraphNodes.forEach(n => {
            n.classList.remove('fade');
            n.classList.remove('highlight-path-segment');
        });
    }, 3000);
  }

  function makeNodeDraggable(nodeEl) {
      let isDragging = false;
      let dragOffsetX, dragOffsetY;
      let originalTransform = '';

      nodeEl.addEventListener('mousedown', function(e) {
          if (e.altKey || e.button === 1) { // Alt key or Middle mouse button
              e.stopPropagation(); // Prevent pan if svg-pan-zoom is active
              
              isDragging = true;
              nodeEl.classList.add('dragging');
              originalTransform = nodeEl.getAttribute('transform') || '';
              
              // Get initial mouse position relative to SVG viewport
              const CTM = svgElement.getScreenCTM();
              const initialMouseX = (e.clientX - CTM.e) / CTM.a;
              const initialMouseY = (e.clientY - CTM.f) / CTM.d;

              // Get current translation of the node
              let currentTranslateX = 0, currentTranslateY = 0;
              const transformMatch = originalTransform.match(/translate\s*\(([^,\s]+)[,\s]+([^\)]+)\)/);
              if (transformMatch) {
                  currentTranslateX = parseFloat(transformMatch[1]);
                  currentTranslateY = parseFloat(transformMatch[2]);
              }
              
              dragOffsetX = initialMouseX - currentTranslateX;
              dragOffsetY = initialMouseY - currentTranslateY;
              
              // Bring to front
              nodeEl.parentNode.appendChild(nodeEl);
              if(svgPanZoomInstance) svgPanZoomInstance.disablePan(); // Disable pan while dragging node
          }
      });

      document.addEventListener('mousemove', function(e) { // Listen on document for wider drag area
          if (isDragging) {
              e.preventDefault();
              const CTM = svgElement.getScreenCTM();
              const mouseX = (e.clientX - CTM.e) / CTM.a;
              const mouseY = (e.clientY - CTM.f) / CTM.d;
              
              const newTranslateX = mouseX - dragOffsetX;
              const newTranslateY = mouseY - dragOffsetY;
              
              nodeEl.setAttribute('transform', `translate(${newTranslateX}, ${newTranslateY})`);
              updateEdges(nodeEl, newTranslateX, newTranslateY);
          }
      });

      document.addEventListener('mouseup', function() {
          if (isDragging) {
              isDragging = false;
              nodeEl.classList.remove('dragging');
              if(svgPanZoomInstance) svgPanZoomInstance.enablePan();
          }
      });
  }
  
  // Basic edge update (highly dependent on Graphviz output structure)
  // This is a placeholder and likely needs significant refinement based on actual SVG structure of edges.
  function updateEdges(node, newTranslateX, newTranslateY) {
    if (!svgElement) return;
    const nodeId = node.getAttribute('id'); // Assumes node has an ID used by edges
    if (!nodeId) return;

    // This is a very simplified example. Edges in Graphviz are complex.
    // It's often better to re-render with Graphviz if dynamic edge updates are critical and complex.
    // Or, use a JS graph library that handles this.

    // Find edges connected to this node (data-source or data-target attributes were added in Python)
    const edges = svgElement.querySelectorAll(`path[data-source="${nodeId}"], path[data-target="${nodeId}"]`);
    
    edges.forEach(edge => {
        // Graphviz edges are paths. Their 'd' attribute defines the line.
        // Updating these correctly without knowing the exact start/end points relative
        // to the node's new position is very hard.
        // A common approach is to find the control points of the path and adjust them.
        // However, Graphviz's path 'd' attribute can be complex (e.g., splines).

        // For a very simple line, you might parse 'd', find M (moveto) and L (lineto)
        // and adjust. But this won't work for splines (C, S commands).
    });
  }
  
  // Collapse/Expand All
  if (expandAllBtn) expandAllBtn.addEventListener('click', function() {
      showLoading(true);
      if (!svgElement) { showLoading(false); return; }
      const allGraphNodes = svgElement.querySelectorAll('g[id^="node_"]');
      allGraphNodes.forEach(node => {
          const nodePath = node.getAttribute('data-name');
          if (nodePath && collapsedNodes.has(nodePath)) { // Only expand if it was collapsed
            toggleNodeCollapse(node, false);
          }
          node.classList.remove('hidden-node'); // Ensure all are visible
      });
      collapsedNodes.clear(); // All are now expanded
      allGraphNodes.forEach(node => updateNodeExpansionIndicator(node));
      showNotification('All nodes expanded.', 'info');
      showLoading(false);
  });
  
  if (collapseAllBtn) collapseAllBtn.addEventListener('click', function() {
      showLoading(true);
      if (!svgElement) { showLoading(false); return; }
      const allGraphNodes = svgElement.querySelectorAll('g[id^="node_"]');
      // Collapse all nodes that have children, starting from top-level
      const topLevelNodes = Array.from(allGraphNodes).filter(node => {
          const path = node.getAttribute('data-name');
          // A top-level node in the context of the graph is one whose data-name does not contain '.'
          // or it's the special 'root' node.
          return path && (path === 'root' || !path.includes('.'));
      });

      topLevelNodes.forEach(node => {
          const modulePath = node.getAttribute('data-name');
          if (getDirectChildNodes(modulePath).length > 0) { // Only collapse if it has children
            toggleNodeCollapse(node, true, true); // true for recursive collapse
          }
      });
      // Any node that is not a top-level but has children and is not already part of a collapsed parent path
      // should also be marked as collapsed if we want a "full" collapse.
      // For now, collapsing top-level recursively should handle most cases.
      allGraphNodes.forEach(node => updateNodeExpansionIndicator(node));
      showNotification('All expandable nodes collapsed.', 'info');
      showLoading(false);
  });
  
  // Function to display module information
  function displayModuleInfo(moduleName) {
      const info = window.moduleInfo ? window.moduleInfo[moduleName] : null;
      if (!infoPanel) return;

      if (!info) {
          infoPanel.innerHTML = `<h3 id="infoPanelHeader">Module: ${moduleName}</h3><p>No detailed information available.</p>`;
          return;
      }
      let html = `<h3 id="infoPanelHeader">Module: ${moduleName}</h3>`;
      html += `<div class="layer-path" lang="en" dir="ltr">${moduleName}</div>`; // Added lang/dir for accessibility
      html += `<button id="copyNameBtnInfoPanel" class="info-panel-button" style="margin-bottom:8px;">Copy Full Name</button>`;
      html += `<table aria-labelledby="infoPanelHeader">`; // Aria for table context
      html += `<thead><tr><th scope="col">Property</th><th scope="col">Value</th></tr></thead>`;
      html += `<tbody>`;
      html += `<tr><th scope="row">Type</th><td>${info.type || 'N/A'}</td></tr>`;
      html += `<tr><th scope="row">Parameters</th><td>${info.parameters?.toLocaleString() || '0'}</td></tr>`;
      html += `<tr><th scope="row">Trainable</th><td>${info.trainable ? 'Yes' : 'No'}</td></tr>`;
      html += `<tr><th scope="row">Class</th><td><code lang="en">${info.class || 'N/A'}</code></td></tr>`;
      html += `<tr><th scope="row">Docstring</th><td>${info.docstring || 'N/A'}</td></tr>`;
      
      for (const [key, value] of Object.entries(info)) {
          if (!['type', 'parameters', 'trainable', 'class', 'docstring'].includes(key)) {
              html += `<tr><th scope="row">${key.charAt(0).toUpperCase() + key.slice(1)}</th><td>${JSON.stringify(value)}</td></tr>`;
          }
      }
      html += `</tbody></table>`;
      infoPanel.innerHTML = html;
      
      const copyBtnInfo = document.getElementById('copyNameBtnInfoPanel');
      if (copyBtnInfo) {
          copyBtnInfo.onclick = function() {
              copyModuleName(moduleName);
          };
      }
  }
  
  // Enhanced search
  if (searchInput) searchInput.addEventListener('input', function() {
    const searchTerm = this.value.trim().toLowerCase();
    const allGraphNodes = svgElement ? svgElement.querySelectorAll('g[id^="node_"]') : [];

    if (searchTerm === '') {
        allGraphNodes.forEach(node => {
            node.style.opacity = 1;
            node.classList.remove('hidden-by-search');
            // Restore visibility based on collapsed state, not just make all visible
            const modulePath = node.getAttribute('data-name');
            if (modulePath) {
                const isHiddenByCollapse = Array.from(collapsedNodes).some(collapsedParentPath => 
                    modulePath.startsWith(collapsedParentPath + '.') && modulePath !== collapsedParentPath
                );
                if (isHiddenByCollapse) {
                    node.classList.add('hidden-node');
                }
            }
        });
        return;
    }

    // Determine if we're using a special filter syntax (key:value)
    const isSpecialFilter = searchTerm.includes(':');
    let filterKey, filterValue;
    
    if (isSpecialFilter) {
        const parts = searchTerm.split(':');
        filterKey = parts[0].trim();
        filterValue = parts.slice(1).join(':').trim(); // In case value contains colons too
    }

    // Search in moduleInfo data (if available) and highlight matching nodes
    const moduleInfoData = window.moduleInfo || {};
    
    allGraphNodes.forEach(node => {
        const modulePath = node.getAttribute('data-name');
        if (!modulePath) {
            node.classList.add('hidden-by-search');
            return;
        }
        
        // Default to hiding
        node.classList.add('hidden-by-search');
        node.style.opacity = 0.3;
        
        // Special filter handling
        if (isSpecialFilter) {
            const moduleData = moduleInfoData[modulePath];
            if (!moduleData) return; // No data to filter on
            
            // Handle different filter types
            let matchesFilter = false;
            
            switch(filterKey) {
                case 'type':
                    matchesFilter = moduleData.type && moduleData.type.toLowerCase().includes(filterValue);
                    break;
                case 'trainable':
                    matchesFilter = 
                        (filterValue === 'yes' && moduleData.trainable) || 
                        (filterValue === 'no' && !moduleData.trainable);
                    break;
                case 'params':
                case 'parameters':
                    if (filterValue.startsWith('>')) {
                        const threshold = parseInt(filterValue.substring(1).trim());
                        matchesFilter = !isNaN(threshold) && moduleData.parameters > threshold;
                    } else if (filterValue.startsWith('<')) {
                        const threshold = parseInt(filterValue.substring(1).trim());
                        matchesFilter = !isNaN(threshold) && moduleData.parameters < threshold;
                    } else {
                        const exactValue = parseInt(filterValue);
                        matchesFilter = !isNaN(exactValue) && moduleData.parameters === exactValue;
                    }
                    break;
                default:
                    // Try to match against any property
                    for (const [key, value] of Object.entries(moduleData)) {
                        if (
                            (key.toLowerCase() === filterKey && 
                             String(value).toLowerCase().includes(filterValue)) || 
                            (String(value).toLowerCase().includes(searchTerm))
                        ) {
                            matchesFilter = true;
                            break;
                        }
                    }
            }
            
            if (matchesFilter) {
                node.classList.remove('hidden-by-search');
                node.style.opacity = 1;
                // Also show all parent nodes in the path
                const parts = modulePath.split('.');
                let currentPath = '';
                for (let i = 0; i < parts.length; i++) {
                    currentPath = i === 0 ? parts[i] : `${currentPath}.${parts[i]}`;
                    const parentNode = svgElement.querySelector(`g[data-name="${currentPath}"]`);
                    if (parentNode) {
                        parentNode.classList.remove('hidden-by-search');
                        parentNode.style.opacity = 1;
                        // Ensure parent nodes are expanded
                        if (collapsedNodes.has(currentPath)) {
                            toggleNodeCollapse(parentNode, false);
                        }
                    }
                }
            }
            
        } else {
            // Simple name search
            if (modulePath.toLowerCase().includes(searchTerm)) {
                node.classList.remove('hidden-by-search');
                node.style.opacity = 1;
                
                // Make sure parents are visible and expanded
                const parts = modulePath.split('.');
                let currentPath = '';
                for (let i = 0; i < parts.length; i++) {
                    currentPath = i === 0 ? parts[i] : `${currentPath}.${parts[i]}`;
                    const parentNode = svgElement.querySelector(`g[data-name="${currentPath}"]`);
                    if (parentNode && parentNode !== node) {
                        parentNode.classList.remove('hidden-by-search');
                        parentNode.style.opacity = 1;
                        
                        // Expand parent if collapsed
                        if (collapsedNodes.has(currentPath)) {
                            toggleNodeCollapse(parentNode, false);
                        }
                    }
                }
            }
        }
    });
  });

  // Search clearing
  if (clearSearch) clearSearch.addEventListener('click', function() {
    if (searchInput) searchInput.value = '';
    // Trigger the input event to clear search results
    const event = new Event('input', { bubbles: true });
    searchInput.dispatchEvent(event);
    searchInput.focus();
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    // Focus search with Ctrl+F
    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault(); // Prevent browser's find
        searchInput.focus();
    }
    
    // Clear search with Escape
    if (e.key === 'Escape') {
        if (searchInput && document.activeElement === searchInput) {
            searchInput.value = '';
            const event = new Event('input', { bubbles: true });
            searchInput.dispatchEvent(event);
        } else if (helpTooltip && helpTooltip.style.display === 'block') {
            toggleHelp(false);
        }
    }
    
    // Show help with ? or Ctrl+H
    if (e.key === '?' || ((e.ctrlKey || e.metaKey) && e.key === 'h')) {
        e.preventDefault();
        toggleHelp(helpTooltip.style.display !== 'block');
    }
  });

  // SVG-pan-zoom keyboard handlers
  document.addEventListener('keydown', function(e) {
      if (!svgPanZoomInstance) return;
      
      // Zoom with + and -
      if (e.key === '+' || e.key === '=') {
          svgPanZoomInstance.zoomIn();
      }
      if (e.key === '-' || e.key === '_') {
          svgPanZoomInstance.zoomOut();
      }
      // Reset with 0
      if (e.key === '0') {
          svgPanZoomInstance.resetZoom();
      }
  });
  
  // Make resize handle functional
  if (resizeHandle && visualizationContainer) {
      let startY, startHeight;
      
      resizeHandle.addEventListener('mousedown', function(e) {
          startY = e.clientY;
          startHeight = parseInt(document.defaultView.getComputedStyle(visualizationContainer).height, 10);
          document.documentElement.addEventListener('mousemove', doDrag, false);
          document.documentElement.addEventListener('mouseup', stopDrag, false);
      });
      
      function doDrag(e) {
          visualizationContainer.style.height = (startHeight + e.clientY - startY) + 'px';
      }
      
      function stopDrag() {
          document.documentElement.removeEventListener('mousemove', doDrag, false);
          document.documentElement.removeEventListener('mouseup', stopDrag, false);
          // After resize, make sure SVG pan-zoom instance is updated
          if (svgPanZoomInstance) {
              svgPanZoomInstance.resize();
              svgPanZoomInstance.fit();
              svgPanZoomInstance.center();
          }
      }
  }
  
  // Load svg-pan-zoom library dynamically if not available
  if (!window.svgPanZoom && svgElement) {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js';
      script.onload = function() {
          console.log('svg-pan-zoom library loaded dynamically');
          initSvgPanZoom();
      };
      document.head.appendChild(script);
  }
});
    </script>

        <div id="configPanel" class="config-panel">
            <div class="config-header">
                <h2>Layer Configuration Generator</h2>
                <button id="closeConfig" title="Close configuration panel">X</button>
            </div>
            <div class="config-body">        <div class="config-section">
                    <h3>Selected Layers <span class="selection-help">(Hold Ctrl/Cmd and click to select multiple layers)</span></h3>
                    <div class="selection-tip">
                        <div class="tip-icon">!</div>
                        <div class="tip-text">Select multiple layers by holding <kbd>Ctrl</kbd> (or <kbd>Cmd</kbd> on Mac) while clicking on layers in the visualization. A blue border will appear when multi-selection mode is active.</div>
                    </div>
                    <div id="selectedLayers" class="selected-layers">
                        <p class="no-selection">No layers selected. Click on layers in the visualization to select them.</p>
                    </div>
                </div>
                <div class="config-section">
                    <h3>Layer Parameters</h3>
                    <div id="paramOptions" class="param-options">
                        <p class="no-selection">Select layer(s) to configure parameters.</p>
                    </div>
                </div>
                <div class="config-section">
                    <h3>Configuration Options</h3>
                    <div class="config-options">
                        <label>
                            <input type="checkbox" id="separateConfig" checked>
                            Configure layers separately
                        </label>
                        <label>
                            <input type="checkbox" id="copyWeights" checked>
                            Copy weights when replacing layers
                        </label>
                    </div>
                </div>
                <div class="config-section">
                    <h3>Generated Configuration</h3>
                    <div class="code-container">
                        <pre id="generatedCode" class="generated-code">
# No configuration generated yet.
# Select layers and parameters to generate code.
</pre>
                        <button id="copyCode" class="code-button" title="Copy code to clipboard">Copy Code</button>
                    </div>
                </div>
                <div class="config-actions">
                    <button id="generateConfig" class="action-button">Generate Configuration</button>
                    <button id="clearSelection" class="action-button secondary">Clear Selection</button>
                </div>
            </div>
        </div>        <button id="showConfig" class="show-config-button">Generate Layer Config</button>
        <div id="multiSelectTooltip" class="multi-select-tooltip">Hold Ctrl/Cmd for multi-select</div>
        <script>
        // Layer types data from Python
        const layerTypes = {"Linear": ["features.0", "features.3", "classifier.0", "classifier.2"]};
        // Configuration options from Python
        const configOptions = {"Linear": {"sketch": ["qr", "svd", "srd"], "sketch_ratio": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]}, "Conv2d": {"sketch": ["qr", "svd", "srd"], "sketch_ratio": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], "kernel_type": ["full", "sr"]}, "MultiheadAttention": {"sketch": ["qr", "svd", "srd"], "sketch_ratio": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], "head_ratio": [0.25, 0.5, 0.75]}};
        // Store selected layers as array of objects: {name, type}
        let selectedLayers = [];
        // Map layer name to type for quick lookup
        let layerNameToType = {};
        
        // Initialize layer name to type mapping
        for (const [type, names] of Object.entries(layerTypes)) {
            for (const name of names) {
                layerNameToType[name] = type;
            }
        }
        
        // Helper: update selected layers UI
        function updateSelectedLayersUI() {
            const container = document.getElementById('selectedLayers');
            
            if (selectedLayers.length === 0) {
                container.innerHTML = '<p class="no-selection">No layers selected. Click on layers in the visualization to select them.</p>';
                return;
            }
            
            // Group layers by type for better organization
            const layersByType = {};
            selectedLayers.forEach(layer => {
                if (!layersByType[layer.type]) {
                    layersByType[layer.type] = [];
                }
                layersByType[layer.type].push(layer);
            });
            
            let html = '';
            
            // Create a section for each type
            for (const [type, layers] of Object.entries(layersByType)) {
                html += `<div class="layer-type-group">
                    <div class="layer-type-header">${type} (${layers.length})</div>
                    <div class="layer-type-items">`;
                    
                for (const layer of layers) {
                    html += `<div class="layer-item">
                        <span class="layer-name">${layer.name}</span>
                        <button class="remove-layer" title="Remove layer" data-layer="${layer.name}">&times;</button>
                    </div>`;
                }
                
                html += `</div></div>`;
            }
            
            container.innerHTML = html;
        }
        
        // Helper: update parameter options UI for multiple types
        function updateParamOptionsUI() {
            const container = document.getElementById('paramOptions');
            
            if (selectedLayers.length === 0) {
                container.innerHTML = '<p class="no-selection">Select layer(s) to configure parameters.</p>';
                return;
            }
            
            // Get all unique layer types from selected layers
            const uniqueTypes = [...new Set(selectedLayers.map(l => l.type))];
            
            let html = '';
            
            // Create UI for each type's parameters
            uniqueTypes.forEach(type => {
                const layersOfType = selectedLayers.filter(l => l.type === type);
                const typeOptions = configOptions[type];
                
                if (!typeOptions || Object.keys(typeOptions).length === 0) {
                    return;
                }
                
                html += `<div class="type-section">
                    <div class="type-header">${type} (${layersOfType.length} layer${layersOfType.length > 1 ? 's' : ''})</div>`;
                
                // Show which layers are included when multiple are selected
                if (layersOfType.length > 1) {
                    html += `<div class="layers-included">
                        Layers included: ${layersOfType.map(l => l.name).join(', ')}
                    </div>`;
                }
                
                // Add parameter groups for this type
                for (const [paramName, paramValues] of Object.entries(typeOptions)) {
                    html += `<div class="param-group" data-layer-type="${type}">
                        <span class="param-name">${paramName}</span>
                        <div class="param-values">`;
                    
                    // Create checkbox for each value
                    for (const value of paramValues) {
                        html += `<label class="param-checkbox">
                            <input type="checkbox" name="param-${type}-${paramName}" value="${value}" data-type="${type}" data-param="${paramName}">
                            ${value}
                        </label>`;
                    }
                    
                    html += `</div></div>`;
                }
                
                html += `</div>`;
            });
            
            container.innerHTML = html || '<p class="no-selection">No configurable parameters for selected layer types.</p>';
        }
        
        // Helper: get selected parameter values grouped by layer type
        function getSelectedParamsByType() {
            const paramsByType = {};
            
            // Get all parameter groups
            document.querySelectorAll('.param-group').forEach(group => {
                const layerType = group.getAttribute('data-layer-type');
                if (!layerType) return;
                
                const paramName = group.querySelector('.param-name').textContent;
                const checkedInputs = group.querySelectorAll('input:checked');
                
                if (checkedInputs.length > 0) {
                    if (!paramsByType[layerType]) {
                        paramsByType[layerType] = {};
                    }
                    
                    paramsByType[layerType][paramName] = Array.from(checkedInputs).map(input => input.value);
                }
            });
            
            return paramsByType;
        }
        
        // Helper: update generated code UI
        function updateGeneratedCodeUI() {
            const codeBox = document.getElementById('generatedCode');
            
            if (selectedLayers.length === 0) {
                codeBox.textContent = '# No configuration generated yet.\n# Select layers and parameters to generate code.';
                return;
            }
            
            const paramsByType = getSelectedParamsByType();
            
            if (Object.keys(paramsByType).length === 0) {
                codeBox.textContent = '# Please select parameters for at least one layer type.';
                return;
            }
            
            const separate = document.getElementById('separateConfig').checked;
            const copyWeights = document.getElementById('copyWeights').checked;
            
            // Group layers by type
            const layersByType = {};
            selectedLayers.forEach(layer => {
                if (!layersByType[layer.type]) {
                    layersByType[layer.type] = [];
                }
                layersByType[layer.type].push(layer.name);
            });
            
            // Generate configurations for each type
            const configs = [];
            
            for (const [type, layerNames] of Object.entries(layersByType)) {
                // Only generate config if parameters are selected for this type
                if (paramsByType[type] && Object.keys(paramsByType[type]).length > 0) {
                    configs.push(generateLayerConfigCode(layerNames, paramsByType[type], separate, copyWeights));
                }
            }
            
            // If no valid configs, show message
            if (configs.length === 0) {
                codeBox.textContent = '# Please select parameters for at least one layer type.';
                return;
            }
            
            // Generate full config code
            let fullCode = '';
            
            if (configs.length === 1) {
                // If only one config, no need for TuningConfigs wrapper
                fullCode = configs[0];
            } else {
                // Wrap multiple configs in TuningConfigs
                fullCode = 'TuningConfigs(\n    configs=[\n' + configs.join(',\n') + '\n    ]\n)';
            }
            
            codeBox.textContent = fullCode;
        }
        
        // Generate LayerConfig code
        function generateLayerConfigCode(layerNames, params, separate, copyWeights) {
            let layerNamesStr;
            
            if (layerNames.length === 1) {
                layerNamesStr = `\"${layerNames[0]}\"`;
            } else {
                layerNamesStr = `[${layerNames.map(name => `\"${name}\"`).join(', ')}]`;
            }
            
            const paramsItems = [];
            
            for (const [paramName, paramValues] of Object.entries(params)) {
                if (paramValues.length > 0) {
                    const valuesStr = paramValues.map(value => {
                        return isNaN(parseFloat(value)) ? `\"${value}\"` : value;
                    }).join(', ');
                    
                    paramsItems.push(`\"${paramName}\": [${valuesStr}]`);
                }
            }
            
            const paramsStr = `{${paramsItems.join(', ')}}`;
            
            return `    LayerConfig(\n        layer_names=${layerNamesStr},\n        params=${paramsStr},\n        separate=${separate},\n        copy_weights=${copyWeights}\n    )`;
        }
        
        // Show tooltip for multiselect
        function showMultiSelectTooltip() {
            const tooltip = document.getElementById('multiSelectTooltip');
            tooltip.style.display = 'block';
            setTimeout(() => {
                tooltip.style.opacity = '1';
            }, 10);
            
            // Hide after 3 seconds
            setTimeout(() => {
                tooltip.style.opacity = '0';
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 300);
            }, 3000);
        }
        
        // Attach event listeners after DOM loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Show multiselect tooltip once when page loads
            setTimeout(showMultiSelectTooltip, 2000);
            
            // Show/hide config panel
            document.getElementById('showConfig').onclick = function() {
                document.getElementById('configPanel').style.display = 'flex';
            };
            
            document.getElementById('closeConfig').onclick = function() {
                document.getElementById('configPanel').style.display = 'none';
            };
            
            // Remove layer from selection
            document.getElementById('selectedLayers').onclick = function(e) {
                if (e.target.classList.contains('remove-layer')) {
                    const name = e.target.getAttribute('data-layer');
                    selectedLayers = selectedLayers.filter(l => l.name !== name);
                    
                    // Unhighlight in visualization
                    unhighlightLayerNode(name);
                    
                    // Update UI
                    updateSelectedLayersUI();
                    updateParamOptionsUI();
                    updateGeneratedCodeUI();
                }
            };
            
            // Clear selection
            document.getElementById('clearSelection').onclick = function() {
                // Unhighlight all selected layers
                for (const layer of selectedLayers) {
                    unhighlightLayerNode(layer.name);
                }
                
                selectedLayers = [];
                
                // Update UI
                updateSelectedLayersUI();
                updateParamOptionsUI();
                updateGeneratedCodeUI();
            };
            
            // Generate config
            document.getElementById('generateConfig').onclick = function() {
                updateGeneratedCodeUI();
            };
            
            // Copy code
            document.getElementById('copyCode').onclick = function() {
                const code = document.getElementById('generatedCode').textContent;
                navigator.clipboard.writeText(code);
                
                // Show feedback
                const button = document.getElementById('copyCode');
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            };
            
            // Update config when options change
            document.getElementById('separateConfig').onchange = updateGeneratedCodeUI;
            document.getElementById('copyWeights').onchange = updateGeneratedCodeUI;
            
            // Update params when changed
            document.getElementById('paramOptions').addEventListener('change', function(e) {
                if (e.target.tagName === 'INPUT' && e.target.type === 'checkbox') {
                    updateGeneratedCodeUI();
                }
            });
            
            // Layer selection in visualization
            const svg = document.querySelector('svg');
            
            // Handle keydown/keyup for Ctrl/Cmd key to show multiselection is available
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    document.getElementById('selectedLayers').classList.add('multi-selection-active');
                    showMultiSelectTooltip();
                }
            });
            
            document.addEventListener('keyup', function(e) {
                if (!e.ctrlKey && !e.metaKey) {
                    document.getElementById('selectedLayers').classList.remove('multi-selection-active');
                }
            });
            
            if (svg) {
                svg.addEventListener('click', function(e) {
                    let node = e.target;
                    
                    // Traverse up to find node with data-layer-name
                    while (node && !node.getAttribute('data-name') && node !== svg) {
                        node = node.parentNode;
                    }
                    
                    if (node && node.getAttribute && node.getAttribute('data-name')) {
                        const name = node.getAttribute('data-name');
                        // Root element is not a layer
                        if (name === 'root') return;
                        const type = layerNameToType[name];
                        
                        if (!type) return; // Skip if not a recognized layer type
                        
                        const idx = selectedLayers.findIndex(l => l.name === name);
                        
                        // If not holding Ctrl key, clear other selections unless clicking on already selected layer
                        if (!e.ctrlKey && !e.metaKey && idx === -1) {
                            // Clear previous selections
                            for (const layer of selectedLayers) {
                                unhighlightLayerNode(layer.name);
                            }
                            selectedLayers = [];
                        }
                        
                        // Toggle selection of clicked layer
                        if (idx === -1) {
                            // Add to selection
                            selectedLayers.push({name, type});
                            highlightLayerNode(name);
                        } else {
                            // Remove from selection
                            selectedLayers.splice(idx, 1);
                            unhighlightLayerNode(name);
                        }
                        
                        // Update UI
                        updateSelectedLayersUI();
                        updateParamOptionsUI();
                        updateGeneratedCodeUI();
                    }
                });
            }
            
            // Highlight/unhighlight helpers
            window.highlightLayerNode = function(name) {
                // Find all nodes with data-name=name
                const nodes = document.querySelectorAll(`[data-name='${name}']`);
                nodes.forEach(n => n.classList.add('node-selected'));
            };
            
            window.unhighlightLayerNode = function(name) {
                const nodes = document.querySelectorAll(`[data-name='${name}']`);
                nodes.forEach(n => n.classList.remove('node-selected'));
            };
            
            // Initial UI
            updateSelectedLayersUI();
            updateParamOptionsUI();
            updateGeneratedCodeUI();
        });
        </script></body>
</html>